{
  "name": "promistreamus",
  "version": "0.1.11",
  "description": "Convert Stream into an Iterator yielding value promises",
  "main": "promistreamus.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/nyurik/promistreamus.git"
  },
  "scripts": {
    "test": "mocha"
  },
  "keywords": [
    "promises",
    "promise",
    "stream",
    "stream-promise",
    "then",
    "thenable",
    "promises-a",
    "promises-aplus",
    "async",
    "await",
    "deferred",
    "deferreds",
    "future"
  ],
  "bugs": {
    "url": "http://github.com/nyurik/promistreamus/issues"
  },
  "author": {
    "name": "Yuri Astrakhan",
    "email": "YuriAstrakhan@gmail.org"
  },
  "license": "MIT",
  "homepage": "https://github.com/nyurik/promistreamus",
  "dependencies": {
    "bluebird": "^3.3.5"
  },
  "devDependencies": {
    "underscore": "^1.8.3",
    "mocha": "^2.4.5"
  },
  "readme": "# Promistreamus  [![Build Status](https://travis-ci.org/nyurik/promistreamus.svg?branch=master)](https://travis-ci.org/nyurik/promistreamus)\nConvert Stream into an Iterator yielding promises of values\n\nAllows `foreach` of promises for a stream:\n\n```\n// preudo-code\nforeach ( promise in promistreamus(stream) ) {\n    promise.then(function(value) { /* use the value */ });\n}\n```\n\nPromistreamus converts stream's values into promises. This allows you to treat streams in a sync \"pull\" fashion, even if the stream values are not ready yet. Wrapping a stream with Promistreamus provides an iterator function. Calling it returns a thenable promise of a value. Once available, the promise is resolved with the value. When the stream ends, all pending promises are resolved with the `undefined` value. On error, all pending promises are rejected with that error.\n\n## Using Promistreamus\n\n``` js\nvar promistreamus = require(\"promistreamus\");\nvar iterator = promistreamus(stream); // Create an iterator from a stream\n\n// Stream item processing function\nvar processor = function() {\n    // Get the promise of the next stream value from the iterator\n    return iterator().then(function(value) {\n        if (value === undefined) {\n            // we are done, no more items in the stream\n            return;\n        }\n        // Process the value\n        ...\n        return processor(); // Continue to the next item\n    });\n};\n\n// Process stream one item at a time\nprocessor().then(function() {\n    // all items were successfully processed\n}, function(err) {\n    // processing failed\n});\n```\n\n## Delayed initialization\nIn an edge case when iteration function is needed before the stream is available, promistreamus can be delay-created with an undefined call, and initialized later with `init(stream)` function.\n\n``` js\nvar promistreamus = require(\"promistreamus\");\n// Create a non-initialized iterator which has .init(stream) method\nvar iterator = promistreamus();\n...\n// init() can be called even after the iterator function has been called\niterator.init(stream);\n```\n\nNote that if the filtering function is needed, it should still be passed as before:\n\n``` js\nvar iterator = promistreamus(undefined, function(row) {...});\n```\n\n\n## Processing multiple values at once\nThe iterator function may be called more than once, without waiting for the first promise to be resolved.\n\n``` js\n// Process all items, 3 items at a time (example uses bluebird npm)\nvar threads = [processor(), processor(), processor()];\nreturn BBPromise.all(threads).then(function() {\n    // all items were successfully processed\n}, function(err) {\n    // processing failed\n});\n```\n\n## Cancellation\nStreaming can be stopped by calling cancel() function on the iterator. All pending promises will be rejected, and the stream will be paused.\n\n``` js\niterator.cancel();\n```\n\n## Filtering and converting values of a promistreamus stream\nOne may wish to map all values of a given promistreamus stream by using a conversion function, and/or to filter them out.\n\n``` js\nvar iterator = promistreamus(stream); // Create an iterator from a stream\n\nvar iterator2 = promistreamus.select(iterator, function (value) {\n     // process the value, and either return a new value, a promise of a new value, or undefined to skip it\n     return ...;\n});\n```\n\n## Joining multiple streams\nGiven a promistreamus style stream of streams - an iterator function that returns promises of sub-iterators,\none may wish to present the values from all sub-iterators together, just like the .NET's LINQ SelectMany() function.\n\n``` js\nvar items = promistreamus(stream); // Create an iterator from a stream\n\n// Convert each value into a separate promistreamus iterator\nvar itemsOfItems = promistreamus.select(iterator, function (value) {\n    return promistreamus(createStream(value));\n});\n\n// Flatten out all subitems\nvar flattenedItems = promistreamus.flatten(itemsOfItems);\n\n```\n",
  "readmeFilename": "README.md",
  "_id": "promistreamus@0.1.11",
  "_shasum": "249ae3774d4783f3c1dc4a4bc99435799609a8e5",
  "_resolved": "https://registry.npmjs.org/promistreamus/-/promistreamus-0.1.11.tgz",
  "_from": "https://registry.npmjs.org/promistreamus/-/promistreamus-0.1.11.tgz"
}
