{
  "name": "protozero",
  "version": "1.4.2",
  "description": "Minimalist protocol buffer decoder and encoder in C++",
  "main": "include_dirs.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/mapbox/protozero.git"
  },
  "readme": "# protozero\n\nMinimalistic protocol buffer decoder and encoder in C++.\n\nDesigned for high performance. Suitable for writing zero copy parsers and\nencoders with minimal need for run-time allocation of memory.\n\nLow-level: this is designed to be a building block for writing a very\ncustomized decoder for a stable protobuf schema. If your protobuf schema\nis changing frequently or lazy decoding is not critical for your application\nthen this approach offers no value: just use the decoding API available via the\nC++ API that can be generated via the Google Protobufs `protoc` program.\n\n[![Travis Build Status](https://travis-ci.org/mapbox/protozero.svg?branch=master)](https://travis-ci.org/mapbox/protozero)\n[![Appveyor Build Status](https://ci.appveyor.com/api/projects/status/o354pq10y96mnr6d?svg=true)](https://ci.appveyor.com/project/Mapbox/protozero)\n[![Coverage Status](https://coveralls.io/repos/mapbox/protozero/badge.svg?branch=master&service=github)](https://coveralls.io/github/mapbox/protozero?branch=master)\n\n## Depends\n\n - C++11 compiler\n\n\n## How it works\n\nThe protozero code does **not** read `.proto` files used by the usual Protobuf\nimplementations. The developer using protozero has to manually \"translate\" the\n`.proto` description into code. This means there is no way to access any of the\ninformation from the `.proto` description. This results in a few restrictions:\n\n* The names of the fields are not available.\n* Enum names are not available, you'll have to use the values they are defined\n  with.\n* Default values are not available.\n* Field types have to be hardcoded. The library does not know which types to\n  expect, so the user of the library has to supply the right types. Some checks\n  are made using `assert()`, but mostly the user has to take care of that.\n\nThe library will make sure not to overrun the buffer it was given, but\nbasically all other checks have to be made in user code!\n\n\n## Documentation\n\nYou have to have a working knowledge of how\n[protocol buffer encoding works](https://developers.google.com/protocol-buffers/docs/encoding).\n\n* Read the [tutorial](doc/tutorial.md) for an introduction on how to use\n  Protozero.\n* There is a table of all types and functions in the\n  [cheat sheet](doc/cheatsheet.md).\n* [Macros defined or used by Protozero](doc/macros.md).\n* Read the [upgrading instructions](UPGRADING.md) if you are upgrading from\n  an older version of Protozero.\n\nCall `make doc` to build the Doxygen-based reference documentation. (You'll\nneed [Doxygen](http://www.stack.nl/~dimitri/doxygen/) installed.) Then open\n`doc/html/index.html` in your browser to read it.\n\n\n## Installation\n\nCall `make install` to install include files in `/usr/include/protozero`. Call\n`make install DESTDIR=/usr/local` or similar to change install directory.\n\n\n## Limitations\n\n* A protobuf message has to fit into memory completely, otherwise it can not\n  be parsed with this library. There is no streaming support.\n* The length of a string, bytes, or submessage can't be more than 2^31-1.\n* The Google Protobuf spec documents that a non-repeated field can actually\n  appear several times in a message and the implementation is required to\n  return the value of the last version of that field in this case.\n  `pbf_reader.hpp` does not enforce this. If this feature is needed in your\n  case, you have to do this yourself.\n* There is no specific support for maps but they can be used as described in\n  the \"Backwards compatibility\" section of\n  https://developers.google.com/protocol-buffers/docs/proto3#maps.\n\n\n## Memory Alignment Issues and Endianness\n\nProtobuf-encoded data is not necessarily properly aligned for the machine we\nare using. For single values this isn't a problem, because we copy those into\na properly aligned variable and return that one. But for repeated packed values\nit can be a problem, because we give users access to them through an iterator.\nTo get the best performance this iterator is usually just a raw pointer. This\nworks fine on Intel processors, non-aligned access is just slower than aligned\naccess. On ARM this is not necessarily the case (depends on machine type and\ncompile options), so we need to go through a special iterator there\nwhich makes sure to return aligned data on member access. Basically the same\niterator is used on big endian architectures to put the bytes in the correct\norder before handing them back to the application.\n\nDetection of endianess and those architectures which have problems with\nnon-aligned data is not perfect. If tests fail for you, this might be a problem\nin your setup. Please open an issue on Github in this case and tell us about\nyour system.\n\nSee also the discussion on https://github.com/mapbox/protozero/issues/33 .\n\n\n## Tests\n\nExtensive tests are included. Call\n\n    make test\n\nto build all tests and run them.\n\nSee `test/README.md` for more details about the test.\n\nYou can also use `gyp` to build the reader tests:\n\n    gyp gyp/protozero.gyp --depth=. --build=Release\n    ./out/Release/tests\n\nThis will clobber the `Makefile` from the repository! Instead of `Release` you\ncan use `Debug` for a debug build.\n\n\n## Coverage report\n\nTo get a coverage report compile and link with `--coverage`:\n\n    CXXFLAGS=\"--coverage\" LDFLAGS=\"--coverage\" make test\n\nIf you are using `g++` use `gcov` to generate a report (results are in `*.gcov`\nfiles):\n\n    gcov -lp test/*tests.o test/t/*/*test_cases.o\n\nIf you are using `clang++` use `llvm-cov` instead:\n\n    llvm-cov gcov -lp test/*tests.o test/t/*/*test_cases.o\n\nIf you are using `g++` you can use `gcovr` to generate nice HTML output:\n\n    mkdir -p coverage\n    gcovr -r . --html --html-details -o coverage/index.html\n\nOpen `coverage/index.html` in your browser to see the report.\n\n\n## Cppcheck\n\nFor extra checks with [Cppcheck](http://cppcheck.sourceforge.net/) you can call\n\n    make check\n\n\n## Who is using Protozero?\n\n* [Carmen](https://github.com/mapbox/carmen-cache)\n* [Libosmium](https://github.com/osmcode/libosmium)\n* [Mapnik](https://github.com/mapbox/mapnik-vector-tile)\n* [Mapbox GL Native](https://github.com/mapbox/mapbox-gl-native)\n* [OSRM](https://github.com/Project-OSRM/osrm-backend)\n* [Tippecanoe](https://github.com/mapbox/tippecanoe)\n\nAre you using Protozero? Tell us! Send a pull request with changes to this\nREADME.\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mapbox/protozero/issues"
  },
  "homepage": "https://github.com/mapbox/protozero#readme",
  "_id": "protozero@1.4.2",
  "_shasum": "58d35f3ac209afa5747fd1a76521b3012195e906",
  "_resolved": "https://registry.npmjs.org/protozero/-/protozero-1.4.2.tgz",
  "_from": "https://registry.npmjs.org/protozero/-/protozero-1.4.2.tgz"
}
