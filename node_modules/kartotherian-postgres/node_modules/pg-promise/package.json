{
  "name": "pg-promise",
  "version": "3.9.1",
  "description": "PostgreSQL via promises",
  "main": "lib/index.js",
  "scripts": {
    "test": "jasmine-node test",
    "test-native": "jasmine-node test --config PG_NATIVE true",
    "doc": "jsdoc -c ./jsdoc/jsDoc.json ./jsdoc/README.md -d ./API",
    "coverage": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test",
    "travis": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test --captureExceptions && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage"
  },
  "files": [
    "lib",
    "typescript"
  ],
  "homepage": "https://github.com/vitaly-t/pg-promise",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vitaly-t/pg-promise.git"
  },
  "bugs": {
    "url": "https://github.com/vitaly-t/pg-promise/issues",
    "email": "vitaly.tomilov@gmail.com"
  },
  "keywords": [
    "pg",
    "pg-promise",
    "postgres",
    "transaction"
  ],
  "author": {
    "name": "Vitaly Tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "license": "MIT",
  "engines": {
    "node": ">=0.10",
    "npm": ">=1.4"
  },
  "dependencies": {
    "pg": "^4.5.3",
    "spex": "^0.4.2",
    "pg-minify": "^0.2.4"
  },
  "devDependencies": {
    "JSONStream": "1.x",
    "bluebird": "3.x",
    "coveralls": "2.x",
    "istanbul": "0.4",
    "jasmine-node": "1.x",
    "jsdoc": "3.x",
    "pg-query-stream": "1.x"
  },
  "readme": "pg-promise\r\n===========\r\n\r\nAdvanced access layer to [node-postgres] via [Promises/A+].\r\n\r\n[![Build Status](https://travis-ci.org/vitaly-t/pg-promise.svg?branch=master)](https://travis-ci.org/vitaly-t/pg-promise)\r\n[![Coverage Status](https://coveralls.io/repos/vitaly-t/pg-promise/badge.svg?branch=master)](https://coveralls.io/r/vitaly-t/pg-promise?branch=master)\r\n[![Package Quality](http://npm.packagequality.com/shield/pg-promise.svg)](http://packagequality.com/#?package=pg-promise)\r\n[![Join the chat at https://gitter.im/vitaly-t/pg-promise](https://badges.gitter.im/vitaly-t/pg-promise.svg)](https://gitter.im/vitaly-t/pg-promise?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n---\r\n<a href=\"https://promisesaplus.com/\"><img align=\"right\" width=\"190\" height=\"190\" src=\"http://s8.postimg.org/k7dtue8lx/pg_promise.jpg\"></a>\r\n\r\n* Supporting [Promise], [Bluebird], [When], [Q], etc.\r\n* Transactions, functions, flexible query formatting;\r\n* Automatic database connections;\r\n* Strict query result filters.\r\n\r\n---\r\n\r\n* [About](#about)\r\n* [Installing](#installing)\r\n* [Getting Started](#getting-started)\r\n  - [Initialization](#initialization)\r\n  - [Connection](#connection)\r\n  - [Documentation](#documentation)  \r\n* [Testing](#testing)    \r\n* [Usage](#usage)\r\n  - [Queries and Parameters](#queries-and-parameters)\r\n    - [Raw Text](#raw-text)  \r\n    - [Open Values](#open-values)    \r\n    - [SQL Names](#sql-names)    \r\n  - [Query Result Mask](#query-result-mask)    \r\n  - [Named Parameters](#named-parameters)\r\n  - [Conversion Helpers](#conversion-helpers)\r\n  - [Custom Type Formatting](#custom-type-formatting)  \r\n    - [Raw Custom Types](#raw-custom-types)   \r\n  - [Query Files](#query-files)    \r\n  - [Connections](#connections)  \r\n    - [Detached Connections](#detached-connections)\r\n    - [Shared Connections](#shared-connections)\r\n    - [Tasks](#tasks)    \r\n  - [Transactions](#transactions)\r\n    - [Detached Transactions](#detached-transactions)\r\n    - [Shared-connection Transactions](#shared-connection-transactions)\r\n    - [Nested Transactions](#nested-transactions)\r\n    - [Synchronous Transactions](#synchronous-transactions)    \r\n    - [Configurable Transactions](#configurable-transactions)\r\n  - [Generators](#generators)\r\n* [Advanced](#advanced)\r\n  - [Initialization Options](#initialization-options)\r\n  - [Library de-initialization](#library-de-initialization)\r\n* [History](#history)\r\n* [License](#license)\r\n\r\n---\r\n\r\n# About\r\n\r\nBuilt on top of [node-postgres] and its connection pool, this library translates their callback interface into one based on [Promises/A+],\r\nwhile extending the protocol to a higher level, with automated connections and transactions management.\r\n\r\nIn addition, the library provides:\r\n\r\n* its own, more flexible query formatting;\r\n* event reporting for connectivity, errors, queries and transactions;\r\n* support for all popular promise libraries + ES6 generators;\r\n* declarative approach to controlling query results.\r\n\r\n# Installing\r\n```\r\n$ npm install pg-promise\r\n```\r\n\r\n# Getting Started\r\n\r\n## Initialization\r\n\r\nLoading and initializing the library with [Initialization Options]:\r\n\r\n```javascript\r\nvar pgp = require('pg-promise')({\r\n    // Initialization Options\r\n});\r\n```\r\n\r\n&#8722; or without [Initialization Options]:\r\n\r\n```javascript\r\nvar pgp = require('pg-promise')();\r\n```\r\n \r\n## Connection\r\n\r\nUse one of the two ways to specify database connection details:\r\n\r\n* Configuration Object:\r\n\r\n```javascript\r\nvar cn = {\r\n    host: 'localhost', // server name or IP address;\r\n    port: 5432,\r\n    database: 'my_db_name',\r\n    user: 'user_name',\r\n    password: 'user_password'\r\n};\r\n```\r\n\r\n* Connection String:\r\n\r\n```javascript\r\nvar cn = 'postgres://username:password@host:port/database';\r\n```\r\n\r\nCreate a global/shared database object from the connection details:\r\n\r\n```javascript\r\nvar db = pgp(cn);\r\n```\r\n\r\nObject `db` represents the database protocol, with lazy database connection, i.e. only the actual query methods acquire\r\nand release the connection. Therefore, you should create only one global/shared `db` object per connection details.\r\n\r\nUse of a configuration object has the benefit of being changeable: it is used by the library directly, and changing\r\nproperties of the original object will reconnect with the next query.\r\n\r\nThis library does not use any of the connection's details, it simply passes them on to [PG] when opening a connection.\r\nFor more details see pg connection parameters in [WiKi](https://github.com/brianc/node-postgres/wiki/pg#parameters) and\r\n[implementation](https://github.com/brianc/node-postgres/blob/master/lib/connection-parameters.js).\r\n\r\nAPI: [Database].\r\n\r\n## Documentation\r\n\r\n[Learn by Example] is the quickest way to get started with this library, while the current document details most of the\r\nbasic functionality this library provides.\r\n\r\nIf you are writing in TypeScript, see [\\typescript](https://github.com/vitaly-t/pg-promise/tree/master/typescript). \r\n\r\nFor the protocol see the [API Documentation], and for everything else - [Wiki pages](https://github.com/vitaly-t/pg-promise/wiki).\r\n\r\n# Testing\r\n\r\n* Clone the repository (or download, if you prefer):\r\n```\r\n$ git clone https://github.com/vitaly-t/pg-promise\r\n```\r\n\r\n* Install the library's DEV dependencies:\r\n```\r\n$ npm install\r\n```\r\n\r\n* Make sure all tests can connect to your local test database, using the connection details in\r\n[test/db/header.js](https://github.com/vitaly-t/pg-promise/blob/master/test/db/header.js).\r\nEither set up your test database accordingly or change the connection details in that file.\r\n\r\n* Initialize the database with some test data:\r\n```\r\n$ node test/db/init.js\r\n```\r\n\r\n* To run all tests:\r\n```\r\n$ npm test\r\n```\r\n\r\n* To run all tests with coverage:\r\n```\r\n$ npm run coverage\r\n```\r\n\r\n# Usage\r\n\r\n## Queries and Parameters\r\n\r\nEvery connection context of the library shares the same query protocol, starting with generic method `query`,\r\ndefined as shown below:\r\n\r\n```javascript\r\nfunction query(query, values, qrm);\r\n```\r\n* `query` (required) - a string with support for three types of formatting, depending on the `values` passed:\r\n   - format `$1` (single variable), if `values` is of type `string`, `boolean`, `number`, `Date`, `function` or `null`;\r\n   - format `$1, $2, etc..`, if `values` is an array;\r\n   - format `$*propName*`, if `values` is an object (not `null` and not `Date`), where `*` is any of the supported open-close pairs: `{}`, `()`, `<>`, `[]`, `//`;\r\n* `values` (optional) - value/array/object to replace the variables in the query;\r\n* `qrm` - (optional) *Query Result Mask*, as explained below. When not passed, it defaults to `pgp.queryResult.any`.\r\n\r\nWhen a value/property inside array/object is an array, it is treated as a [PostgreSQL Array Type](http://www.postgresql.org/docs/9.4/static/arrays.html),\r\nconverted into the array constructor format of `array[]`, the same as calling method `pgp.as.array()`.\r\n\r\nWhen a value/property inside array/object is of type `object` (except for `null`, `Date` or `Buffer`), it is automatically\r\nserialized into JSON, the same as calling method `pgp.as.json()`, except the latter would convert anything to JSON.\r\n\r\nFor the most current SQL formatting support see method [as.format]\r\n\r\n### Raw Text\r\n\r\nRaw-text values can be injected by ending the variable name with `^` or `:raw`:\r\n`$1^, $2^, etc...`, `$*varName^*`, where `*` is any of the supported open-close pairs: `{}`, `()`, `<>`, `[]`, `//`\r\n\r\nRaw text is injected without any pre-processing, which means:\r\n\r\n* No proper escaping (replacing each single-quote symbol `'` with two);\r\n* No wrapping text into single quotes.\r\n\r\nUnlike regular variables, value for raw-text variables cannot be `null` or `undefined`, because of the ambiguous meaning\r\nin this case. If such values are passed in, the formatter will throw error `Values null/undefined cannot be used as raw text.` \r\n\r\nSpecial syntax `this^` within the [Named Parameters](#named-parameters) refers to the formatting object itself, to be injected\r\nas a raw-text JSON-formatted string.\r\n\r\nFor the most current SQL formatting support see method [as.format]\r\n\r\n### Open Values\r\n\r\nOpen values were added in version 3.4.0, to simplify concatenation of string values within a query,\r\nprimarily for such special cases as `LIKE` filters.\r\n\r\nNames for open-value variables end with either `:value` or symbol `#`, and it means that such a value\r\nis to be properly formatted and escaped, but not to be wrapped in quotes when it is a text.\r\n\r\nSimilar to raw-text variables, open-value variables are also not allowed to be `null` or `undefined`, and they\r\nwill throw error `Open values cannot be null or undefined.` And the difference is that raw-text variables are not\r\nescaped, while open-value variables are properly escaped.\r\n\r\nBelow is an example of formatting `LIKE` filter that ends with a value: \r\n\r\n```js\r\n// using $1# or $1:value syntax:\r\nquery(\"...WHERE name LIKE '%$1#'\", \"berg\");\r\nquery(\"...WHERE name LIKE '%$1:value'\", \"berg\");\r\n\r\n// using ${propName#} or ${propName:value} syntax:\r\nquery(\"...WHERE name LIKE '%${filter#}'\", {filter: \"berg\"});\r\nquery(\"...WHERE name LIKE '%${filter:value}'\", {filter: \"berg\"});\r\n```\r\n\r\nThe formatting protocol has been also extended with method [as.value].\r\n\r\n### SQL Names\r\n\r\nIntroduced in version 3.1.0, this feature simplifies formatting for SQL names/identifiers.\r\n\r\nWhen a variable ends with `~` (tilde) or `:name`, it represents an SQL name or identifier, which must be a text\r\nstring of at least 1 character long. Such name is then properly escaped and wrapped in double quotes.\r\n\r\n```js\r\nquery('INSERT INTO $1~($2~) VALUES(...)', ['Table Name', 'Column Name']);\r\n// => INSERT INTO \"Table Name\"(\"Column Name\") VALUES(...)\r\n\r\nquery('SELECT ${column~} FROM ${table~}', {\r\n    column: 'Column Name',\r\n    table: 'Table Name'\r\n});\r\n// => SELECT \"Column Name\" FROM \"Table Name\"\r\n```\r\n\r\nRelying on this type of formatting for sql names and identifiers, along with regular variable formatting\r\nmakes your application impervious to sql injection.\r\n\r\nSee methods: [as.name], [as.format]\r\n\r\n## Query Result Mask\r\n\r\nIn order to eliminate the chances of unexpected query results and thus make the code more robust,\r\nmethod `query` uses parameter `qrm` (Query Result Mask):\r\n\r\n```js\r\n///////////////////////////////////////////////////////\r\n// Query Result Mask flags;\r\n//\r\n// Any combination is supported, except for one + many.\r\nvar queryResult = {\r\n    /** Single row is expected. */\r\n    one: 1,\r\n    /** One or more rows expected. */\r\n    many: 2,\r\n    /** Expecting no rows. */\r\n    none: 4,\r\n    /** many|none - any result is expected. */\r\n    any: 6\r\n};\r\n```\r\n\r\nIn the following generic-query example we indicate that the call can return anything:\r\n```javascript\r\ndb.query('select * from users');\r\n```\r\nwhich is equivalent to making one of the following calls:\r\n```javascript\r\nvar qrm = pgp.queryResult;\r\ndb.query('select * from users', undefined, qrm.many | qrm.none);\r\ndb.query('select * from users', undefined, qrm.any);\r\ndb.manyOrNone('select * from users');\r\ndb.any('select * from users');\r\n```\r\n\r\nThis usage pattern is facilitated through result-specific methods that can be used instead of the generic query:\r\n\r\n```javascript\r\ndb.many(query, values); // expects one or more rows\r\ndb.one(query, values); // expects a single row\r\ndb.none(query, values); // expects no rows\r\ndb.any(query, values); // expects anything, same as `manyOrNone`\r\ndb.oneOrNone(query, values); // expects 1 or 0 rows\r\ndb.manyOrNone(query, values); // expects anything, same as `any`\r\n```\r\n\r\nThere is however one specific method `result(query, values)` to bypass any result verification, and instead resolve\r\nwith the original [Result] object passed from the [PG] library.\r\n\r\nYou can also add your own methods and properties to this protocol via the [extend](#extend) event.  \r\n\r\nEach query function resolves its **data** according to the `qrm` that was used:\r\n\r\n* `none` - **data** is `undefined`. If the query returns any kind of data, it is rejected.\r\n* `one` - **data** is a single object. If the query returns no data or more than one row of data, it is rejected.\r\n* `many` - **data** is an array of objects. If the query returns no rows, it is rejected.\r\n* `one`|`none` - **data** is `null`, if no data was returned; or a single object, if one row was returned.\r\n    If the query returns more than one row of data, the query is rejected.\r\n* `many`|`none` - **data** is an array of objects. When no rows are returned, **data** is an empty array.\r\n\r\nIf you try to specify `one`|`many` in the same query, such query will be rejected without executing it, telling you that such mask is invalid.\r\n\r\nIf `qrm` is not specified when calling generic `query` method, it is assumed to be `many`|`none` = `any`, i.e. any kind of data expected.\r\n\r\n> This is all about writing robust code, when the client specifies what kind of data it is ready to handle on the declarative level,\r\nleaving the burden of all extra checks to the library.\r\n\r\n## Named Parameters\r\n\r\nThe library supports named parameters in query formatting, with the syntax of `$*propName*`, where `*` is any of the following open-close\r\npairs: `{}`, `()`, `<>`, `[]`, `//`\r\n\r\n```javascript\r\ndb.query('select * from users where name=${name} and active=$/active/', {\r\n    name: 'John',\r\n    active: true\r\n});\r\n```\r\n\r\nThe same goes for all types of query methods as well as method [as.format], where `values` can also be an object whose properties can be\r\nreferred to by name from within the query.\r\n\r\nA valid property name consists of any combination of letters, digits, underscores or `$`, and they are case-sensitive.\r\nLeading and trailing spaces around property names are ignored.\r\n\r\nIt is important to know that while property values `null` and `undefined` are both formatted as `null`,\r\nan error is thrown when the property doesn't exist at all (except for `partial` replacements - see below).\r\n\r\nVersion 3.2.0 added support for `partial` replacements within method [as.format], which when used will simply ignore variables that do not\r\nexist in the formatting object.\r\n\r\n#### `this` reference\r\n\r\nVersion 2.3.0 added support for property `this`, as a reference to the formatting object itself,\r\nso it can be inserted as a JSON-formatted string, alongside its properties.\r\n\r\n* `${this}` - inserts the object itself as a JSON-formatted string;\r\n* `${this^}` - inserts the object itself as a raw-text JSON-formatted string.\r\n\r\n**example:**\r\n\r\n```js\r\nvar doc = {\r\n    id: 123,\r\n    body: \"some text\"\r\n};\r\n\r\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\r\n    .then(function () {\r\n        // success;\r\n    })\r\n    .catch(function (error) {\r\n        // error;\r\n    });\r\n```    \r\n\r\nwhich will execute:\r\n```\r\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\r\n```\r\n\r\nVersion 3.2.1 and later allows syntax `:json` as an alternative to formatting the value as a JSON string.\r\n\r\n**NOTE:** Technically, it is possible in javascript, though not recommended, for an object to contain a property\r\nwith name `this`. And in such cases the property's value will be used instead.\r\n\r\n## Functions and Procedures\r\n\r\nIn PostgreSQL stored procedures are just functions that usually do not return anything.\r\n\r\nSuppose we want to call function **findAudit** to find audit records by `user_id` and maximum timestamp.\r\nWe can make such call as shown below:\r\n\r\n```javascript\r\ndb.func('findAudit', [123, new Date()])\r\n    .then(function (data) {\r\n        console.log(data); // printing the data returned\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // printing the error\r\n    });\r\n```\r\n\r\nWe passed it `user_id = 123`, plus current Date/Time as the timestamp. We assume that the function signature matches\r\nthe parameters that we passed. All values passed are serialized automatically to comply with PostgreSQL type formats.\r\n\r\nMethod `func` accepts optional third parameter - `qrm` (Query Result Mask), the same as method `query`.\r\n\r\nAnd when you are not expecting any return results, call `db.proc` instead. Both methods return a [Promise] object,\r\nbut `db.proc` doesn't take a `qrm` parameter, always assuming it is `one`|`none`.\r\n\r\nSummary for supporting procedures and functions:\r\n\r\n* `func(query, values, qrm)` - expects the result according to `qrm`\r\n* `proc(query, values)` - calls `func(query, values, qrm.one | qrm.none)`\r\n\r\n## Conversion Helpers\r\n\r\nThe library provides several helper functions to convert javascript types into their proper PostgreSQL presentation that can be passed\r\ndirectly into queries or functions as parameters. All of such helper functions are located within namespace [pgp.as], and each function\r\nreturns a formatted string when successful or throws an error when it fails.\r\n\r\n## Custom Type Formatting\r\n\r\nWhen we pass `values` as a single parameter or inside an array, it is verified to be an object\r\nthat supports function `formatDBType`, as either its own or inherited. And if the function exists,\r\nits return result overrides both the actual value and the formatting syntax for parameter `query`.\r\n\r\nThis allows use of your own custom types as formatting parameters for the queries, as well as\r\noverriding formatting for standard object types, such as `Date` and `Array`.\r\n\r\n**Example: your own type formatting**\r\n```javascript\r\nfunction Money(m) {\r\n    this.amount = m;\r\n    this.formatDBType = function () {\r\n        // return a string with 2 decimal points;\r\n        return this.amount.toFixed(2);\r\n    }\r\n}\r\n```\r\n\r\n**Example: overriding standard types**\r\n```javascript\r\nDate.prototype.formatDBType = function () {\r\n    // format Date as a local timestamp;\r\n    return this.getTime();\r\n};\r\n```\r\n\r\nFunction `formatDBType` is allowed to return absolutely anything, including:\r\n* instance of another object that supports its own custom formatting;\r\n* instance of another object that doesn't have its own custom formatting;\r\n* another function, with recursion of any depth;\r\n\r\nPlease note that the return result from `formatDBType` may even affect the\r\nformatting syntax expected within parameter `query`, as explained below.\r\n\r\nIf you pass in `values` as an object that has function `formatDBType`,\r\nand that function returns an array, then your `query` is expected to use \r\n`$1, $2` as the formatting syntax.\r\n\r\nAnd if `formatDBType` in that case returns a custom-type object that doesn't support\r\ncustom formatting, then `query` will be expected to use `$*propName*` as the formatting syntax.\r\n\r\n### Raw Custom Types\r\n\r\nThis features allows overriding `raw` flag for the values returned from custom types.\r\n\r\nAny custom type or standard type that implements function `formatDBType` can also set\r\nproperty `_rawDBType = true` to force raw variable formatting on the returned value.\r\n\r\nThis makes the custom type formatting ultimately flexible, as there is no limitation\r\nas to how a custom type can format its value.\r\n\r\nFor example, some special types, like UUID, do not have natural presentation in JavaScript,\r\nso they have to be converted into text strings when passed into the query formatting.\r\nFor an array of UUID-s, for instance, you would have to explicitly cast the formatted value\r\nwith `::uuid[]` appended at the end of the variable.\r\n  \r\nYou can implement your own presentation for UUID that does not require extra casting:\r\n\r\n```javascript  \r\nfunction UUID(value) {\r\n    this.uuid = value;\r\n    this._rawDBType = true; // force raw format on output;\r\n    this.formatDBType = function () {\r\n        // alternatively, you can set flag\r\n        // _rawDBType during this call:\r\n        // this._rawDBType = true;\r\n        return this.uuid;\r\n    };\r\n}\r\n``` \r\n  \r\nWhen you chain one custom-formatting type to return another one, please note that\r\nsetting `_rawDBType` on any level will set the flag for the entire chain.\r\n\r\n## Query Files\r\n  \r\nVersion 2.9.0 introduced support for Query Files to increase productivity of developing SQL queries. \r\n\r\nExample:\r\n\r\n```js\r\nfunction sql(file) {\r\n    return new pgp.QueryFile(file, {minify: true});\r\n}\r\n\r\n// Create QueryFile globally, once per file:\r\nvar sqlFindUser = sql('./sql/findUser.sql');\r\n\r\ndb.one(sqlFindUser, {id: 123})\r\n    .then(user=> {\r\n        console.log(user);\r\n    })\r\n    .catch(error=> {\r\n        if (error instanceof pgp.minify.SQLParsingError) {\r\n            // => failed to parse the SQL file\r\n        }\r\n    });\r\n```\r\n  \r\nFile `findUser.sql`:\r\n```sql\r\n/*\r\n    multi-line comment\r\n*/\r\nSELECT name, dob -- single-line comment\r\nFROM Users\r\nWHERE id = ${id}\r\n```\r\n\r\nEvery query method of the library recognizes type `QueryFile` as a query provider.\r\n\r\nYou should only create a single instance of `QueryFile` per file, and then use that instance throughout the application.\r\n\r\nMost useful features of class `QueryFile`:\r\n\r\n* `debug` mode, to make every query request check if the file has changed since it was last read, and if so - read it afresh.\r\n  This way you can write sql queries and see immediate updates without having to restart your application.\r\n* Added in v3.2.0: `params` option for static SQL pre-formatting, to inject certain values only once, like a schema name or a\r\n  configurable table name.\r\n\r\nThe query provider itself never throws any error, leaving it for query methods to reject with.\r\n\r\nFor detailed documentation see [QueryFile API].\r\n\r\n## Connections\r\n\r\nThe library supports promise-chained queries on shared and detached connections. Choosing which one to use depends on the\r\nsituation and personal preferences.\r\n\r\n### Detached Connections\r\n\r\nQueries in a detached promise chain maintain connection independently, they each acquire a connection from the pool,\r\nexecute the query and then release the connection back to the pool.\r\n\r\n```javascript\r\ndb.one('select * from users where id = $1', 123) // find the user from id;\r\n    .then(function (data) {\r\n        // find 'login' records for the user found:\r\n        return db.query('select * from audit where event=$1 and userId=$2',\r\n            ['login', data.id]);\r\n    })\r\n    .then(function (data) {\r\n        console.log(data); // display found audit records;\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // display the error;\r\n    });\r\n```\r\nIn a situation where a single request is to be made against the database, a detached chain is the only one that makes sense.\r\nAnd even if you intend to execute multiple queries in a chain, keep in mind that even though each will use its own connection,\r\nsuch will be used from a connection pool, so effectively you end up with the same connection, without any performance penalty.\r\n\r\n### Shared Connections\r\n\r\n**NOTE:** With the addition of [Tasks](#tasks), use of shared connections directly is considered obsolete.\r\nIt is recommended that you use [Tasks](#tasks) instead, as they are much easier and safer to use.\r\n\r\nA promise chain with a shared connection starts with `connect()`, which acquires a connection from the pool to be shared\r\nwith all the queries down the promise chain. The connection must be released back to the pool when no longer needed.\r\n\r\n```javascript\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function (obj) {\r\n        sco = obj; // save the connection object;\r\n        // find active users created before today:\r\n        return sco.query('select * from users where active=$1 and created < $2',\r\n            [true, new Date()]);\r\n    })\r\n    .then(function (data) {\r\n        console.log(data); // display all the user details;\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // display the error;\r\n    })\r\n    .finally(function () {\r\n        if (sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\n\r\nShared-connection chaining is when you want absolute control over the connection, either because you want to execute lots of queries in one go,\r\nor because you like squeezing every bit of performance out of your code. Other than that, the author hasn't seen any performance difference\r\nfrom the detached-connection chaining. And besides, any long sequence of queries normally resides inside a task or transaction, which always\r\nuses shared-connection chaining automatically.\r\n\r\n### Tasks\r\n\r\nA task represents a shared connection to be used within a callback function. The callback can be either a regular function or an ES6 generator.\r\n\r\nA transaction, for example, is just a special type of task, wrapped in `CONNECT->COMMIT/ROLLBACK`. \r\n\r\n```javascript\r\ndb.task(function (t) {\r\n    // t = this;\r\n    // execute a chain of queries;\r\n})\r\n    .then(function (data) {\r\n        // success;\r\n    })\r\n    .catch(function (error) {\r\n        // failed;    \r\n    });\r\n```\r\n\r\nThe purpose of tasks is simply to provide a shared connection context within the callback function to execute and return\r\na promise chain, and then automatically release the connection.\r\n\r\nIn other words, it is to simplify the use of [shared connections](#shared-connections), so instead of calling `connect` in the beginning\r\nand `done` in the end (if it was connected successfully), one can call `db.task` instead, execute all queries within\r\nthe callback and return the result.\r\n\r\n## Transactions\r\n\r\nTransactions can be executed within both shared and detached promise chains in the same way, performing the following actions:\r\n\r\n1. Acquires a new connection (detached chains only);\r\n2. Executes `BEGIN` command;\r\n3. Invokes your callback function (or generator) with the connection object;\r\n4. Executes `COMMIT`, if the callback resolves, or `ROLLBACK`, if the callback rejects;\r\n5. Releases the connection (detached chains only);\r\n6. Resolves with the callback result, if success; rejects with the reason, if failed.\r\n\r\n### Detached Transactions\r\n\r\n```javascript\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    // creating a sequence of transaction queries:\r\n    var q1 = this.none('update users set active=$1 where id=$2', [true, 123]);\r\n    var q2 = this.one('insert into audit(entity, id) values($1, $2) returning id',\r\n        ['users', 123]);\r\n\r\n    // returning a promise that determines a successful transaction:\r\n    return this.batch([q1, q2]); // all of the queries are to be resolved;\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // printing successful transaction output;\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // printing the error;\r\n    });\r\n```\r\n\r\nA detached transaction acquires a connection and exposes object `t`=`this` to let all containing queries\r\nexecute on the same connection.\r\n\r\n### Shared-connection Transactions\r\n\r\n**NOTE:** Use of shared-connection transactions is no longer necessary. When a transaction needs\r\nto use the connection from its container, you should execute it inside a task instead.  \r\n\r\n```js\r\nvar sco; // shared connection object;\r\ndb.connect()\r\n    .then(function (obj) {\r\n        sco = obj;\r\n        return sco.oneOrNone('select * from users where active=$1 and id=$1', [true, 123]);\r\n    })\r\n    .then(function (data) {\r\n        return sco.tx(function (t) {\r\n            // t = this;\r\n            var q1 = this.none('update users set active=$1 where id=$2', [false, data.id]);\r\n            var q2 = this.one('insert into audit(entity, id) values($1, $2) returning id',\r\n                ['users', 123]);\r\n\r\n            // returning a promise that determines a successful transaction:\r\n            return this.batch([q1, q2]); // all of the queries are to be resolved;\r\n        });\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // printing the error;\r\n    })\r\n    .finally(function () {\r\n        if (sco) {\r\n            sco.done(); // release the connection, if it was successful;\r\n        }\r\n    });\r\n```\r\n\r\nIf you need to execute just one transaction, the detached transaction pattern is all you need.\r\nBut even if you need to combine it with other queries in a detached chain, it will work the same.\r\nAs stated earlier, choosing a shared chain over a detached one is mostly a matter of special requirements\r\nand/or personal preference.\r\n\r\n### Nested Transactions\r\n\r\nSimilar to the shared-connection transactions, nested transactions automatically share the connection between all levels.\r\nThis library sets no limitation as to the depth (nesting levels) of transactions supported.\r\n\r\nExample:\r\n\r\n```javascript\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    var queries = [\r\n        this.none('drop table users;'),\r\n        this.none('create table users(id serial not null, name text not null)')\r\n    ];\r\n    for (var i = 1; i <= 100; i++) {\r\n        queries.push(this.none('insert into users(name) values($1)', 'name-' + i));\r\n    }\r\n    queries.push(\r\n        this.tx(function (t1) {\r\n            // t1 = this != t;\r\n            return this.tx(function (t2) {\r\n                // t2 = this != t1 != t;\r\n                return this.one('select count(*) from users');\r\n            });\r\n        }));\r\n    return this.batch(queries);\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // printing transaction result;\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // printing the error;\r\n    });\r\n```\r\n\r\n#### Limitations\r\n\r\nIt is important to know that PostgreSQL doesn't have proper support for nested transactions, it only\r\nsupports *partial rollbacks* via [savepoints](http://www.postgresql.org/docs/9.4/static/sql-savepoint.html) inside transactions.\r\nThe difference between the two techniques is huge, as explained further.\r\n\r\nProper support for nested transactions means that the result of a successful sub-transaction isn't rolled back\r\nwhen its parent transaction is rolled back. But with PostgreSQL save-points, if you roll-back the top-level\r\ntransaction, the result of all inner save-points is also rolled back.\r\n\r\nSave-points are only good for *partial rollbacks*, i.e. you can roll-back results of sub-transactions, with\r\nyet successful *commit* for the top-level transaction. Using promises it is easy to construct your transaction\r\nso it would utilize that logic. This library automatically provides a transaction on the top level, and\r\nsave-points for all sub-transactions.\r\n\r\n### Synchronous Transactions\r\n\r\nA regular task/transaction with a set of independent queries relies on method [batch] to resolve\r\nall queries asynchronously.\r\n\r\nHowever, when it comes to executing a significant number of queries during a bulk `INSERT` or `UPDATE`,\r\nsuch approach is no longer practical. For one thing, it implies that all requests have been created as promise objects,\r\nwhich isn't possible when dealing with a huge number of queries, due to memory limitations imposed by NodeJS.\r\nAnd for another, when one query fails, the rest will continue trying to execute, due to their promise nature,\r\nas being asynchronous.\r\n\r\nThis is why within each task/transaction we have method [sequence], to be able to execute a strict\r\nsequence of queries one by one, and if one fails - the rest won't try to execute.\r\n\r\n```js\r\nfunction source(index, data, delay) {\r\n    // must create and return a promise object dynamically,\r\n    // based on the index of the sequence;\r\n    switch (index) {\r\n        case 0:\r\n            return this.query('select 0');\r\n        case 1:\r\n            return this.query('select 1');\r\n        case 2:\r\n            return this.query('select 2');\r\n    }\r\n    // returning or resolving with undefined ends the sequence;\r\n    // throwing an error will result in a reject;\r\n}\r\n\r\ndb.tx(function (t) {\r\n    // t = this;\r\n    return this.sequence(source);\r\n})\r\n    .then(function (data) {\r\n        console.log(data); // print result;\r\n    })\r\n    .catch(function (error) {\r\n        console.log(error); // print the error;\r\n    });\r\n```\r\n\r\nSequence is based on implementation of [spex.sequence].\r\n\r\n### Configurable Transactions\r\n\r\nIn order to be able to fine-tune database requests in a highly asynchronous environment,\r\nPostgreSQL supports *Transaction Snapshots*, plus 3 ways of configuring a transaction:\r\n\r\n* [SET TRANSACTION](http://www.postgresql.org/docs/9.4/static/sql-set-transaction.html), to configure the current transaction,\r\nwhich your can execute as the very first query in your transaction function;\r\n* `SET SESSION CHARACTERISTICS AS TRANSACTION` - setting default transaction properties for the entire session; \r\n* [BEGIN](http://www.postgresql.org/docs/9.4/static/sql-begin.html) + `Transaction Mode` - initiates a pre-configured transaction.\r\n\r\nThe first method is quite usable, but that means you have to start every transaction with\r\nan initial query to configure the transaction, which can be a bit awkward.\r\n\r\nThe second approach isn't very usable within a database framework as this one, which relies\r\non a connection pool, so you don't really know when a new connection is created.\r\n\r\nThe last method is not usable, because transactions in this library are automatic, executing `BEGIN`\r\nwithout your control, or so it was until version 2.5.0, which changed that, as explained further.\r\n\r\n---  \r\n\r\nVersion 2.5.0 added support for [Transaction Mode], which can extend `BEGIN` in your transaction with\r\na complete set of configuration parameters.\r\n\r\n```js\r\nvar TransactionMode = pgp.txMode.TransactionMode;\r\nvar isolationLevel = pgp.txMode.isolationLevel;\r\n \r\n// Create a reusable transaction mode (serializable + read-only + deferrable):\r\nvar tmSRD = new TransactionMode({\r\n    tiLevel: isolationLevel.serializable,\r\n    readOnly: true,\r\n    deferrable: true\r\n});\r\n\r\nfunction myTransaction() {\r\n    return this.query('SELECT * FROM table');\r\n}\r\n\r\nmyTransaction.txMode = tmSRD; // assign transaction mode;\r\n\r\ndb.tx(myTransaction)\r\n    .then(function(){\r\n        // success;\r\n    });\r\n```\r\n\r\nInstead of the default `BEGIN`, such transaction will initiate with the following command:\r\n```\r\nBEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE\r\n```\r\n\r\nTransaction Mode is set via property `txMode` on the transaction function.\r\n\r\nThis is the most efficient and best-performing way of configuring transactions. In combination with\r\n*Transaction Snapshots* you can make the most out of transactions in terms of performance and concurrency.\r\n\r\n## Generators\r\n\r\nVersion 2.6.0 added support for ES6 generators. If you prefer writing asynchronous code in a synchronous manner,\r\nyou can implement your tasks and transactions as generators. \r\n\r\n```js\r\nfunction * getUser(t) {\r\n    // t = this;\r\n    let user = yield this.oneOrNone('select * from users where id=$1', 123);\r\n    return yield user || this.one('insert into users(name) values($1) returning *', 'John');\r\n}\r\n\r\ndb.task(getUser)\r\n    .then(function (user) {\r\n        // success;\r\n    })\r\n    .catch(function (error) {\r\n        // error;\r\n    });\r\n```\r\n\r\nThe library verifies whether the callback function is a generator, and executes it accordingly.\r\n\r\n# Advanced\r\n\r\n## Initialization Options\r\n\r\nWhen initializing the library, you can pass object `options` with a set of global properties.\r\nSee [API / options](http://vitaly-t.github.io/pg-promise/module-pg-promise.html) for complete list of supported options.\r\n\r\n---\r\n#### pgFormatting\r\n\r\nBy default, **pg-promise** provides its own implementation of the query formatting,\r\nas explained in [Queries and Parameters](#queries-and-parameters).\r\n\r\nIf, however, you want your queries formatted by the [PG] library, set parameter `pgFormatting`\r\nto be `true` when initializing the library, and every query formatting will redirect to the [PG]'s implementation.\r\n\r\nAlthough this has a huge implication to the library's functionality, it is not within the scope of this project to detail.\r\nFor any further reference you should use documentation of the [PG] library.\r\n\r\nNote the following formatting features implemented by [pg-promise] that are not in [node-postgres]:\r\n* [Custom Type Formatting](#custom-type-formatting)\r\n* Single-value formatting: [pg-promise] doesn't require use of an array when passing a single value;\r\n* [Raw-Text](https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example#raw-text) support: injecting raw/pre-formatted text values into the query;\r\n* Functions as formatting parameters, with the actual values returned from the callbacks;\r\n* [PostgreSQL Array Constructors](http://www.postgresql.org/docs/9.1/static/arrays.html#ARRAYS-INPUT) are used when formatting arrays,\r\nnot the old string syntax;\r\n* Automatic conversion of numeric `NaN`, `+Infinity` and `-Infinity` into their string presentation;\r\n* Support for [this reference](#this-reference);\r\n\r\n**NOTE:** Formatting parameters for calling functions (methods `func` and `proc`) is not affected by this override.\r\nWhen needed, use the generic `query` instead to invoke functions with redirected query formatting.\r\n\r\n---\r\n#### promiseLib\r\n\r\nBy default, **pg-promise** uses ES6 Promise. If your version of NodeJS doesn't support ES6 Promise,\r\nor you want a different promise library to be used, set this property to the library's instance.\r\n\r\nExample of switching over to [Bluebird]:\r\n```javascript\r\nvar promise = require('bluebird');\r\nvar options = {\r\n    promiseLib: promise\r\n};\r\nvar pgp = require('pg-promise')(options);\r\n```\r\n\r\n[Promises/A+] libraries that implement a recognizable promise signature and work automatically:\r\n\r\n* **ES6 Promise** - used by default, though it doesn't have `done()` or `finally()`.\r\n* [Bluebird] - best alternative all around;\r\n* [Promise] - very solid library;\r\n* [When] - quite old, not the best support;\r\n* [Q] - most widely used;\r\n* [RSVP] - doesn't have `done()`, use `finally/catch` instead\r\n* [Lie] - doesn't have `done()`. \r\n\r\nIf you pass in a library that doesn't implement a recognizable promise signature, **pg-promise** will\r\nthrow error `Invalid promise library specified.` during initialization.\r\n\r\nFor such libraries you can use [Promise Adapter] to make them compatible with **pg-promise**,\r\nmostly needed by smaller and simplified [Conformant Implementations](https://promisesaplus.com/implementations). \r\n\r\n## Library de-initialization\r\n\r\nWhen exiting your application, you can make the following call:\r\n```javascript\r\npgp.end();\r\n```\r\nThis will release [pg] connection pool globally and make sure that the process terminates without any delay.\r\nIf you do not call it, your process may be waiting for 30 seconds (default for [poolIdleTimeout](https://github.com/brianc/node-postgres/blob/master/lib/defaults.js#L31)),\r\nwaiting for the connection to expire in the pool.\r\n\r\nIf, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\r\n\r\n# History\r\n\r\n* 3.9.0 Prepared Statements support rewritten, adding new type [PreparedStatement]. Released: April 20, 2016\r\n* 3.8.0 Added Database Context support (see [Database]). Released: April 14, 2016\r\n* 3.7.1 Adding internal typescript support to the library. Released: April 10, 2016\r\n* 3.7.0 Modifying the protocol to accommodate changes in `pg` 4.5.3 for isolated [Native Bindings]. Released: April 9, 2016\r\n* 3.6.0 Extending [QueryResultError] for better diagnostics. Released: April 8, 2016\r\n* 3.5.0 Adding support for [Native Bindings]. Released: April 06, 2016\r\n* 3.4.0 Adding support for [Open Values](#open-values) and type `Buffer`. Released: March 20, 2016\r\n* 3.3.0 Adding strict variable requirement to `$1, $2,...` formatting. Released: March 05, 2016\r\n* 3.2.1 Adding support for formatting overrides: `:raw`, `:name`, `:json` and `:csv`. Released: February 22, 2016\r\n* 3.2.0 Adding formatting options support, specifically option `partial`, add its use within [Query Files](#query-files). Released: February 20, 2016\r\n* 3.1.0 Adding support for [SQL Names]. Released: January 27, 2016\r\n* 3.0.3 Complete replacement of the API with GitHub-hosted one. Released: January 21, 2016\r\n* 2.9.3 Replaced all SQL processing with [pg-minify] dependency. Released: January 20, 2016\r\n* 2.9.1 added custom SQL parser for external files. Released: January 19, 2016\r\n* 2.9.0 added support for [Query Files](#query-files). Released: January 18, 2016\r\n* 2.8.0 added support for [event receive](#receive). Released: December 14, 2015\r\n* 2.6.0 added support for [ES6 Generators](#generators). Released: November 30, 2015\r\n* 2.5.0 added support for [Configurable Transactions](#configurable-transactions). Released: November 26, 2015\r\n* 2.4.0 library re-organized for better documentation and easier maintenance. Released: November 24, 2015\r\n* 2.2.0 major rework on the nested transactions support. Released: October 23, 2015\r\n* 2.0.8 added all the [long-outstanding breaking changes](https://github.com/vitaly-t/pg-promise/wiki/2.0-Migration). Released: October 12, 2015\r\n* 1.11.0 added [noLocking](#nolocking) initialization option. Released: September 30, 2015.\r\n* 1.10.3 added enforced locks on every level of the library. Released: September 11, 2015.\r\n* 1.10.0 added support for `batch` execution within tasks and transactions. Released: September 10, 2015.\r\n* 1.9.5 added support for [Raw Custom Types](#raw-custom-types). Released: August 30, 2015.\r\n* 1.9.3 added support for [Custom Type Formatting](#custom-type-formatting). Released: August 30, 2015.\r\n* 1.9.0 added support for [Tasks](#tasks) + initial [jsDoc](https://github.com/jsdoc3/jsdoc) support. Released: August 21, 2015.\r\n* 1.8.2 added support for [Prepared Statements](https://github.com/brianc/node-postgres/wiki/Prepared-Statements). Released: August 01, 2015.\r\n* 1.8.0 added support for Query Streaming via [node-pg-query-stream](https://github.com/brianc/node-pg-query-stream). Released: July 23, 2015.\r\n* 1.7.2 significant code refactoring and optimizations; added support for super-massive transactions. Released: June 27, 2015.\r\n* 1.6.0 major update for the test platform + adding coverage. Released: June 19, 2015.\r\n* 1.5.0 major changes in architecture and query formatting. Released: June 14, 2015.\r\n* 1.4.0 added `this` context to all callbacks where applicable. Released: May 31, 2015.\r\n* 1.3.1 extended [Named Parameters](#named-parameters) syntax to support `{}`,`()`,`[]`,`<>` and `//`. Released: May 24, 2015.\r\n* 1.3.0 much improved error handling and reporting. Released: May 23, 2015.\r\n* 1.2.0 extended [Named Parameters](#named-parameters) syntax with `$(varName)`. Released: May 16, 2015.\r\n* 1.1.0 added support for functions as parameters. Released: April 3, 2015.\r\n* 1.0.5 added strict query sequencing for transactions. Released: April 26, 2015.\r\n* 1.0.3 added method `queryRaw(query, values)`. Released: April 19, 2015.\r\n* 1.0.1 improved error reporting for queries. Released: April 18, 2015.\r\n* 1.0.0 official release milestone. Released: April 17, 2015.\r\n* 0.9.8 added native json support, extended numeric support for `NaN`, `+Infinity` and `-Infinity`. Released: April 16, 2015.\r\n* 0.9.7 received support for protocol extensibility. Released: April 15, 2015.\r\n* 0.9.5 received support for raw-text variables. Released: April 12, 2015.\r\n* 0.9.2 received support for PostgreSQL Array Types. Released: April 8, 2015.\r\n* 0.9.0 changed the notification protocol. Released: April 7, 2015.\r\n* 0.8.4 added support for error notifications. Released: April 6, 2015.\r\n* 0.8.0 added support for named-parameter formatting. Released: April 3, 2015.\r\n* 0.7.0 fixes the way `as.format` works (breaking change). Released: April 2, 2015.\r\n* 0.6.2 has good database test coverage. Released: March 28, 2015.\r\n* 0.5.6 introduces support for nested transaction. Released: March 22, 2015.\r\n* 0.5.3 - minor changes; March 14, 2015.\r\n* 0.5.1 included wider support for alternative promise libraries. Released: March 12, 2015.\r\n* 0.5.0 introduces many new features and fixes, such as properties **pgFormatting** and **promiseLib**. Released on March 11, 2015.\r\n* 0.4.9 represents a solid code base, backed up by comprehensive testing. Released on March 10, 2015.\r\n* 0.4.0 is a complete rewrite of most of the library, made first available on March 8, 2015.\r\n* 0.2.0 introduced on March 6th, 2015, supporting multiple databases.\r\n* 0.1.4 first release. March 5th, 2015.\r\n* 0.0.1 initial draft. March 3rd, 2015.\r\n\r\n# License\r\n\r\nCopyright (c) 2016 Vitaly Tomilov (vitaly.tomilov@gmail.com)\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\nDEALINGS IN THE SOFTWARE.\r\n\r\n[PreparedStatement]:http://vitaly-t.github.io/pg-promise/PreparedStatement.html\r\n[Database]:http://vitaly-t.github.io/pg-promise/Database.html\r\n[QueryResultError]:http://vitaly-t.github.io/pg-promise/QueryResultError.html\r\n[Native Bindings]:https://github.com/brianc/node-postgres#native-bindings\r\n[Initialization Options]:#advanced\r\n[pgp.as]:http://vitaly-t.github.io/pg-promise/formatting.html\r\n[as.value]:http://vitaly-t.github.io/pg-promise/formatting.html#.value\r\n[as.format]:http://vitaly-t.github.io/pg-promise/formatting.html#.format\r\n[as.name]:http://vitaly-t.github.io/pg-promise/formatting.html#.name\r\n[batch]:http://vitaly-t.github.io/pg-promise/Task.html#.batch\r\n[sequence]:http://vitaly-t.github.io/pg-promise/Task.html#.sequence\r\n[API]:http://vitaly-t.github.io/pg-promise\r\n[API Documentation]:http://vitaly-t.github.io/pg-promise\r\n[QueryFile API]:http://vitaly-t.github.io/pg-promise/QueryFile.html\r\n[Transaction Mode]:http://vitaly-t.github.io/pg-promise/txMode.TransactionMode.html\r\n[pg-minify]:https://github.com/vitaly-t/pg-minify\r\n[pg-monitor]:https://github.com/vitaly-t/pg-monitor\r\n[pg-promise]:https://github.com/vitaly-t/pg-promise\r\n[PG]:https://github.com/brianc/node-postgres\r\n[pg]:https://github.com/brianc/node-postgres\r\n[node-postgres]:https://github.com/brianc/node-postgres\r\n[Promises/A+]:https://promisesaplus.com/\r\n[Promise]:https://github.com/then/promise\r\n[Bluebird]:https://github.com/petkaantonov/bluebird\r\n[When]:https://github.com/cujojs/when\r\n[Q]:https://github.com/kriskowal/q\r\n[RSVP]:https://github.com/tildeio/rsvp.js\r\n[Lie]:https://github.com/calvinmetcalf/lie\r\n[Learn by Example]:https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example\r\n[Promise Adapter]:https://github.com/vitaly-t/pg-promise/wiki/Promise-Adapter\r\n[spex.sequence]:https://github.com/vitaly-t/spex/blob/master/docs/code/sequence.md\r\n[Result]:https://github.com/brianc/node-postgres/blob/master/lib/result.js#L6\r\n",
  "readmeFilename": "README.md",
  "_id": "pg-promise@3.9.1",
  "_shasum": "7721ad875caefd1495b824a78c8636c98627735f",
  "_resolved": "https://registry.npmjs.org/pg-promise/-/pg-promise-3.9.1.tgz",
  "_from": "https://registry.npmjs.org/pg-promise/-/pg-promise-3.9.1.tgz"
}
