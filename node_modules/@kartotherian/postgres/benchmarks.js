'use strict';

var Promise = require('bluebird'),
    core = require('@kartotherian/core'),
    ElapsedTime = require('elapsed-time'),
    Postgres = require('./Postgres');

core.tilelive = {protocols:{}};

Postgres.initKartotherian(core);

Promise.promisifyAll(Postgres.prototype);

let total = 0, count = 0, runs = 0;

new Postgres({
    query: {
        database: 'tiles',
        username: 'osm',
        password: 'osm',
    }
}, (err, p) => {
    function run() {
        return doOneRun(p).then(
            () => {
                runs++;
                if (runs < 600) {
                    return run();
                }
            }
        );
    }

    var et = ElapsedTime.new().start();
    return run().then(
        () => {
            console.log('avg', et.getRawValue() / count, ' count ', count, ' runs ', runs, ' elapsed ', et.getValue(), ' per sec ', Math.round(count/et.getRawValue()*1000000000));
            process.exit();
        }
    );
});


function doOneRun(p) {

    let zoom = 0,
        index = 0,
        max = Math.pow(4, zoom);

    return p.getTileAsync(0, 0, 0).then(()=> {

        function run() {
            if (index >= max) {
                zoom++;
                if (zoom > 3) return;
                index = 0;
                max = Math.pow(4, zoom);
            }
            let xy = qidx.indexToXY(index++);
            count++;
            return p.getTileAsync(zoom, xy[0], xy[1]).then(()=>run()).catch(err=> {
                if (!core.isNoTileError(err)) throw err;
                return run();
            });
        }

        return run();
    }).catch(err=> {
        if (index > 0) {
            let xy = qidx.indexToXY(index - 1);
            console.log('failed at ' + xy[0] + ',' + xy[1] + ' zoom ' + zoom);
        } else {
            console.log(err);
            console.log(err.stack);
        }
        throw err;
    });
}
